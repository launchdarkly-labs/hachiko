"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMigrationPR = isMigrationPR;
exports.extractHachikoLabels = extractHachikoLabels;
exports.extractMigrationMetadata = extractMigrationMetadata;
exports.generateMigrationPRLabels = generateMigrationPRLabels;
exports.generateMigrationPRTitle = generateMigrationPRTitle;
exports.generateMigrationPRBody = generateMigrationPRBody;
/**
 * Check if a PR is managed by Hachiko
 */
function isMigrationPR(pr) {
    if (!pr.labels)
        return false;
    return pr.labels.some((label) => label.name.startsWith("hachiko") || label.name.startsWith("migration"));
}
/**
 * Extract Hachiko-specific labels from a PR
 */
function extractHachikoLabels(pr) {
    if (!pr.labels)
        return [];
    return pr.labels
        .map((label) => label.name)
        .filter((name) => name.startsWith("hachiko:") || name.startsWith("migration:"));
}
/**
 * Extract migration metadata from PR labels and branch name
 */
function extractMigrationMetadata(pr) {
    // Try to extract from labels first
    const hachikoLabels = extractHachikoLabels(pr);
    for (const label of hachikoLabels) {
        if (label.startsWith("hachiko:step:")) {
            const parts = label.replace("hachiko:step:", "").split(":");
            if (parts.length >= 2 && parts[0] && parts[1]) {
                return {
                    planId: parts[0],
                    stepId: parts[1],
                    chunk: parts[2] || undefined,
                };
            }
        }
    }
    // Fall back to parsing branch name
    if (pr.head?.ref) {
        const { parseMigrationBranchName } = require("./git.js");
        return parseMigrationBranchName(pr.head.ref);
    }
    return null;
}
/**
 * Generate labels for a migration PR
 */
function generateMigrationPRLabels(planId, stepId, chunk, additionalLabels = []) {
    const labels = [
        "hachiko",
        "migration",
        `hachiko:plan:${planId}`,
        `hachiko:step:${planId}:${stepId}${chunk ? `:${chunk}` : ""}`,
        ...additionalLabels,
    ];
    return labels;
}
/**
 * Generate a PR title for a migration step
 */
function generateMigrationPRTitle(planTitle, stepDescription, chunk) {
    const chunkSuffix = chunk ? ` (${chunk})` : "";
    return `Hachiko: ${planTitle} - ${stepDescription}${chunkSuffix}`;
}
/**
 * Generate a PR body for a migration step
 */
function generateMigrationPRBody(planId, stepId, stepDescription, planUrl, chunk, promptVersion) {
    const chunkText = chunk ? `\n- **Chunk**: ${chunk}` : "";
    const planLink = planUrl ? `\n- **Plan**: [${planId}](${planUrl})` : `\n- **Plan**: ${planId}`;
    const promptText = promptVersion ? `\n- **Prompt Version**: ${promptVersion}` : "";
    return `This pull request was automatically generated by Hachiko as part of a migration.

## Migration Details
- **Step**: ${stepId}
- **Description**: ${stepDescription}${chunkText}${planLink}${promptText}

## Review Checklist
- [ ] Changes look correct and complete
- [ ] Tests pass
- [ ] No unintended side effects
- [ ] Ready to merge

**Note**: This PR is part of an automated migration. After merging, the next step will be automatically queued.

---
*Generated by [Hachiko](https://github.com/launchdarkly/hachiko)*`;
}
//# sourceMappingURL=pr.js.map