name: Execute Migration Step

# Triggered by migration-dashboard workflow or manually
on:
  workflow_dispatch:
    inputs:
      migration_id:
        description: "Migration ID to execute"
        required: true
        type: string
      step_id:
        description: "Step number to execute"
        required: true
        type: string
      force:
        description: "Force execution even if already in progress"
        required: false
        type: boolean
        default: false

permissions:
  contents: write # To create PRs and update files
  issues: write # To update control-plane issue
  pull-requests: write # To create and manage PRs
  actions: write # To trigger workflow dispatches

jobs:
  execute-migration-step:
    name: Execute Migration Step
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@fe02b34f77f8bc703788d5817da081398fad5dd2 # v4.0.0

      - name: Setup Node.js
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8 # v4.0.3
        with:
          node-version: 22
          cache: "pnpm"
          cache-dependency-path: 'pnpm-lock.yaml'

      - name: Install dependencies
        run: |
          pnpm install
          pnpm build

      - name: Load migration configuration
        id: migration
        env:
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          MIGRATION_FILE="migrations/${MIGRATION_ID}.md"

          # Check if migration file exists
          if [ ! -f "$MIGRATION_FILE" ]; then
            echo "‚ùå Migration file not found: $MIGRATION_FILE"
            exit 1
          fi

          # Extract static config from frontmatter (title, agent, total_steps, etc.)
          FRONTMATTER=$(awk '/^---$/{if(f==1) exit; f=1; next} f' "$MIGRATION_FILE")

          if [ -z "$FRONTMATTER" ]; then
            echo "‚ùå No frontmatter found in migration file"
            exit 1
          fi

          # Parse static fields from frontmatter
          TITLE=$(echo "$FRONTMATTER" | grep "^title:" | sed 's/title: *//' | tr -d "'" | tr -d '"')
          AGENT=$(echo "$FRONTMATTER" | grep "^agent:" | sed 's/agent: *//' | tr -d "'" | tr -d '"')
          TOTAL_STEPS=$(echo "$FRONTMATTER" | grep "^total_steps:" | sed 's/total_steps: *//')

          # Get calculated state from PR activity
          echo "üîç Calculating migration state from PR activity..."
          STATE_OUTPUT=$(GITHUB_TOKEN="${GITHUB_TOKEN}" GITHUB_REPOSITORY="${{ github.repository }}" node dist/scripts/get-migration-state.js "$MIGRATION_ID" 2>/dev/null || echo "")

          if [ -z "$STATE_OUTPUT" ]; then
            echo "‚ö†Ô∏è Could not calculate state from PR activity, falling back to frontmatter"
            STATUS=$(echo "$FRONTMATTER" | grep "^status:" | sed 's/status: *//' | tr -d "'" | tr -d '"')
            CURRENT_STEP=$(echo "$FRONTMATTER" | grep "^current_step:" | sed 's/current_step: *//')
            echo "üìä Status: $STATUS (from frontmatter)"
          else
            # Parse the calculated state
            STATUS=$(echo "$STATE_OUTPUT" | grep "^status=" | cut -d'=' -f2)
            CURRENT_STEP=$(echo "$STATE_OUTPUT" | grep "^current_step=" | cut -d'=' -f2)
            echo "üìä Status: $STATUS (calculated from PR activity)"
          fi

          echo "migration_file=$MIGRATION_FILE" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "current_step=$CURRENT_STEP" >> $GITHUB_OUTPUT
          echo "total_steps=$TOTAL_STEPS" >> $GITHUB_OUTPUT

          echo "üìã Migration: $TITLE"
          echo "ü§ñ Agent: $AGENT"
          echo "üìà Progress: $CURRENT_STEP/$TOTAL_STEPS"

      - name: Validate execution conditions
        env:
          MIGRATION_STATUS: ${{ steps.migration.outputs.status }}
          CURRENT_STEP: ${{ steps.migration.outputs.current_step }}
          REQUESTED_STEP: ${{ github.event.inputs.step_id }}
          FORCE: ${{ github.event.inputs.force }}
        run: |
          echo "Validating execution conditions..."

          # Check if migration is in a valid state for execution
          if [ "$MIGRATION_STATUS" = "completed" ] && [ "$FORCE" != "true" ]; then
            echo "‚ùå Migration already completed. Use force=true to override."
            exit 1
          fi

          # Validate CURRENT_STEP is a valid number
          if ! [[ "$CURRENT_STEP" =~ ^[0-9]+$ ]] || [ "$CURRENT_STEP" -lt 1 ]; then
            echo "‚ö†Ô∏è Invalid current step '$CURRENT_STEP', defaulting to 1"
            CURRENT_STEP=1
          fi

          # Validate REQUESTED_STEP is a valid number
          if ! [[ "$REQUESTED_STEP" =~ ^[0-9]+$ ]] || [ "$REQUESTED_STEP" -lt 1 ]; then
            echo "‚ùå Invalid requested step '$REQUESTED_STEP'"
            exit 1
          fi

          # Calculate next step for validation
          NEXT_STEP=$((CURRENT_STEP + 1))

          echo "üîç Validation state:"
          echo "  Migration Status: $MIGRATION_STATUS"
          echo "  Current Step: $CURRENT_STEP"
          echo "  Requested Step: $REQUESTED_STEP"
          echo "  Next Step: $NEXT_STEP"
          echo "  Force: $FORCE"

          # For active/paused status, only allow if re-executing current step or advancing to next step
          if [ "$MIGRATION_STATUS" = "active" ] || [ "$MIGRATION_STATUS" = "paused" ]; then
            if [ "$FORCE" != "true" ]; then
              if [ "$REQUESTED_STEP" != "$CURRENT_STEP" ] && [ "$REQUESTED_STEP" != "$NEXT_STEP" ]; then
                echo "‚ùå Migration $MIGRATION_STATUS. Can only re-execute current step ($CURRENT_STEP) or advance to next step ($NEXT_STEP). Use force=true to override."
                echo "üêõ Debug info: REQUESTED_STEP='$REQUESTED_STEP', CURRENT_STEP='$CURRENT_STEP', NEXT_STEP='$NEXT_STEP'"
                exit 1
              fi
            fi
          fi

          # Validate step number - allow current step or next step (for automatic advancement)
          if [ "$REQUESTED_STEP" != "$CURRENT_STEP" ] && [ "$REQUESTED_STEP" != "$NEXT_STEP" ] && [ "$FORCE" != "true" ]; then
            echo "‚ùå Requested step ($REQUESTED_STEP) doesn't match current step ($CURRENT_STEP) or next step ($NEXT_STEP)"
            exit 1
          fi

          if [ "$REQUESTED_STEP" = "$NEXT_STEP" ]; then
            echo "üîÑ Advancing to next step: $REQUESTED_STEP (current: $CURRENT_STEP)"
          elif [ "$REQUESTED_STEP" = "$CURRENT_STEP" ]; then
            echo "üîÑ Re-executing current step: $REQUESTED_STEP"
          fi

          echo "‚úÖ Execution conditions validated"

      - name: Configure git for agents
        run: |
          # Configure git for potential agent commits
          git config user.name "hachiko[bot]"
          git config user.email "hachiko@users.noreply.github.com"

          echo "‚úÖ Git configured for agent use"

      - name: Log execution start
        env:
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
          STEP_ID: ${{ github.event.inputs.step_id }}
        run: |
          echo "üöÄ Starting execution of migration $MIGRATION_ID step $STEP_ID"
          echo "Migration status and current step are now calculated dynamically from PR activity"

      - name: Execute migration with cloud agent
        id: execute
        env:
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
          MIGRATION_FILE: ${{ steps.migration.outputs.migration_file }}
          AGENT: ${{ steps.migration.outputs.agent }}
          STEP_ID: ${{ github.event.inputs.step_id }}
          DEVIN_API_KEY: ${{ secrets.DEVIN_API_KEY }}
          DEVIN_ORG_ID: ${{ secrets.DEVIN_ORG_ID || vars.DEVIN_ORG_ID }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_WEBHOOK_URL: ${{ secrets.CURSOR_WEBHOOK_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "üöÄ Executing migration step with $AGENT agent..."

          # Generate agent instructions using CLI
          echo "üîß Generating agent instructions..."
          echo "Migration ID: $MIGRATION_ID"
          echo "Step ID: $STEP_ID"
          echo "Agent: $AGENT"
          echo "Repository: ${{ github.repository }}"

          # Check if migration file exists
          MIGRATION_FILE="migrations/${MIGRATION_ID}.md"
          if [ ! -f "$MIGRATION_FILE" ]; then
            echo "‚ùå Migration file not found: $MIGRATION_FILE"
            echo "Available migration files:"
            ls -la migrations/ || echo "migrations/ directory not found"
            echo "success=false" >> $GITHUB_OUTPUT
            echo "error=Migration file not found: $MIGRATION_FILE" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "‚úÖ Migration file found: $MIGRATION_FILE"

          # Check if CLI is working
          echo "üîç Testing migration CLI..."
          if ! pnpm migration --help > /dev/null 2>&1; then
            echo "‚ùå Migration CLI not working"
            echo "success=false" >> $GITHUB_OUTPUT
            echo "error=Migration CLI not accessible" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "‚úÖ Migration CLI is accessible"

          # Generate agent instructions with detailed error capture
          echo "üöÄ Running: pnpm migration get-agent-instructions \"$MIGRATION_ID\" \"$STEP_ID\" \"$AGENT\" --repository \"${{ github.repository }}\""

          # Capture both stdout and stderr
          if ! AGENT_INSTRUCTIONS=$(pnpm migration get-agent-instructions "$MIGRATION_ID" "$STEP_ID" "$AGENT" --repository "${{ github.repository }}" 2>&1); then
            echo "‚ùå Failed to generate agent instructions"
            echo "Exit code: $?"
            echo "Output/Error: $AGENT_INSTRUCTIONS"
            echo "Environment info:"
            echo "Node version: $(node --version)"
            echo "NPM version: $(npm --version)"
            echo "PNPM version: $(pnpm --version)"
            echo "Working directory: $(pwd)"
            echo "success=false" >> $GITHUB_OUTPUT
            echo "error=Failed to generate agent instructions" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ Agent instructions generated successfully"
          echo "Instructions length: ${#AGENT_INSTRUCTIONS} characters"

          # Execute based on agent type
          case "$AGENT" in
            "devin")
              echo "ü§ñ Using Devin API v3beta1..."
              
              if [ -z "$DEVIN_API_KEY" ] || [ -z "$DEVIN_ORG_ID" ]; then
                echo "‚ùå Devin API credentials not configured"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Missing Devin API credentials" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Create Devin session
              echo "Creating Devin session..."
              SESSION_RESPONSE=$(curl -s -X POST "https://api.devin.ai/v3beta1/organizations/$DEVIN_ORG_ID/sessions" \
                -H "Authorization: Bearer $DEVIN_API_KEY" \
                -H "Content-Type: application/json" \
                -H "User-Agent: Hachiko/1.0" \
                -d "{
                  \"name\": \"Hachiko Migration: $MIGRATION_ID Step $STEP_ID\",
                  \"description\": \"Automated migration execution - Step $STEP_ID\",
                  \"repositoryUrl\": \"https://github.com/${{ github.repository }}\",
                  \"branch\": \"main\",
                  \"prompt\": $(echo "$AGENT_INSTRUCTIONS" | jq -Rs .)
                }")

              echo "Devin API Response: $SESSION_RESPONSE"
              
              # Extract session_id from API response (changed from .id to .session_id)
              SESSION_ID=$(echo "$SESSION_RESPONSE" | jq -r '.session_id // empty')
              if [ -z "$SESSION_ID" ]; then
                echo "‚ùå Failed to create Devin session"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Failed to create Devin session" >> $GITHUB_OUTPUT
                exit 1
              fi

              echo "‚úÖ Created Devin session: $SESSION_ID"
              echo "üîó Session URL: https://app.devin.ai/sessions/$SESSION_ID"
              
              # Session created successfully - Devin will work independently and create PR
              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=false" >> $GITHUB_OUTPUT  # Changes will come via PR
              echo "output=Devin session created successfully, working independently" >> $GITHUB_OUTPUT
              echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
              ;;

            "cursor")
              echo "ü§ñ Using Cursor API..."
              
              if [ -z "$CURSOR_API_KEY" ]; then
                echo "‚ùå Cursor API key not configured"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Missing Cursor API key" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Validate API key format and length
              echo "üîç Validating Cursor API key..."
              if [ ${#CURSOR_API_KEY} -lt 10 ]; then
                echo "‚ùå Cursor API key appears invalid (length: ${#CURSOR_API_KEY})"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Invalid Cursor API key format" >> $GITHUB_OUTPUT
                exit 1
              fi
              echo "‚úÖ API key format validation passed (length: ${#CURSOR_API_KEY})"

              # Create Cursor agent task
              CURSOR_AUTH=$(echo -n "$CURSOR_API_KEY:" | base64)
              echo "üîê Authorization header prepared"
              
              # Prepare webhook field if provided
              if [ -n "$CURSOR_WEBHOOK_URL" ]; then
                WEBHOOK_FIELD=",\"webhook_url\": $(echo "$CURSOR_WEBHOOK_URL" | jq -Rs .)"
                echo "üîó Webhook URL configured"
              else
                WEBHOOK_FIELD=""
                echo "üîó No webhook URL configured"
              fi
              
              # Create request payload using actual Cursor API format (based on API error response)
              REQUEST_PAYLOAD="{
                \"prompt\": $(echo "$AGENT_INSTRUCTIONS" | jq -Rs .)${WEBHOOK_FIELD}
              }"
              
              echo "üöÄ Making Cursor API request..."
              echo "Endpoint: https://api.cursor.com/v0/agents"
              echo "Payload size: ${#REQUEST_PAYLOAD} bytes"
              
              # Make API call with error handling
              echo "üîß Making Cursor API request..."
              
              # Write payload to temporary file to avoid shell escaping issues
              PAYLOAD_FILE=$(mktemp)
              echo "$REQUEST_PAYLOAD" > "$PAYLOAD_FILE"
              
              # Temporarily disable exit-on-error to capture curl's exit code
              set +e
              
              # Debug: Show exact command being executed
              echo "üîç Debugging curl command construction:"
              echo "  - PAYLOAD_FILE: $PAYLOAD_FILE"
              echo "  - CURSOR_AUTH length: ${#CURSOR_AUTH}"
              echo "  - Payload file contents:"
              cat "$PAYLOAD_FILE" | head -5
              echo "  - Write-out format test:"
              echo 'Testing: curl -w "\nSTATUS_CODE:%{http_code}"'
              
              # Test each curl parameter individually to isolate the exact issue
              echo "üîç Testing curl parameters systematically to find exit code 43 root cause..."
              
              # Test 1: Minimal curl test
              echo "Test 1: Basic curl version check"
              curl -s --version > /dev/null && echo "  ‚úÖ curl works" || echo "  ‚ùå curl broken"
              
              # Test 2: Test auth header separately  
              echo "Test 2: Auth header validation"
              echo "  - Auth length: ${#CURSOR_AUTH} chars"
              echo "  - Auth preview: ${CURSOR_AUTH:0:20}..."
              
              # Test 3: Test payload file
              echo "Test 3: Payload file validation"
              echo "  - File: $PAYLOAD_FILE"
              echo "  - Exists: $([ -f "$PAYLOAD_FILE" ] && echo 'YES' || echo 'NO')"
              echo "  - Size: $(wc -c < "$PAYLOAD_FILE") bytes"
              
              # Test 4: Progressive curl complexity
              echo "Test 4: Progressive curl test"
              set +e
              
              # 4a: Most basic curl  
              BASIC_RESPONSE=$(curl -s "https://httpbin.org/get" 2>&1)
              BASIC_EXIT=$?
              echo "  - Basic GET exit: $BASIC_EXIT"
              
              # 4b: POST with headers but no auth
              HEADERS_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" "https://httpbin.org/post" 2>&1)
              HEADERS_EXIT=$?  
              echo "  - POST + headers exit: $HEADERS_EXIT"
              
              # 4c: Add auth header (this might be the problem)
              AUTH_RESPONSE=$(curl -s -X POST -H "Authorization: Basic $CURSOR_AUTH" "https://httpbin.org/post" 2>&1)
              AUTH_EXIT=$?
              echo "  - POST + auth header exit: $AUTH_EXIT"
              
              # 4d: Add payload file (this might be the problem)  
              PAYLOAD_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "@$PAYLOAD_FILE" "https://httpbin.org/post" 2>&1)
              PAYLOAD_EXIT=$?
              echo "  - POST + payload file exit: $PAYLOAD_EXIT"
              
              set -e
              
              # Report test results but continue to use --user flag fix
              if [ $BASIC_EXIT -ne 0 ]; then
                echo "‚ùå ISSUE: Basic curl failing (curl installation problem)"
                exit 1
              elif [ $HEADERS_EXIT -ne 0 ]; then
                echo "‚ùå ISSUE: Headers causing curl exit code 43"
                exit 1  
              elif [ $AUTH_EXIT -ne 0 ]; then
                echo "‚ÑπÔ∏è  EXPECTED: Authorization header causing curl exit code 43 (will use --user flag instead)"
              elif [ $PAYLOAD_EXIT -ne 0 ]; then
                echo "‚ùå ISSUE: Payload file causing curl exit code 43"
                exit 1
              else
                echo "‚úÖ All curl parameter tests passed"
              fi
              
              # Use curl --user flag instead of Authorization header to avoid exit code 43
              echo "üîß Making Cursor API request with --user authentication..."
              HTTP_RESPONSE=$(curl -s \
                -X POST "https://api.cursor.com/v0/agents" \
                --user "$CURSOR_API_KEY:" \
                -H "Content-Type: application/json" \
                -H "User-Agent: Hachiko/1.0" \
                -d "@$PAYLOAD_FILE" 2>&1)
              
              CURL_EXIT_CODE=$?
              set -e  # Re-enable exit-on-error
              
              # Clean up payload file
              rm -f "$PAYLOAD_FILE"
              
              echo "üîç Curl exit code: $CURL_EXIT_CODE"
              
              if [ $CURL_EXIT_CODE -ne 0 ]; then
                echo "‚ùå Curl command failed with exit code $CURL_EXIT_CODE"
                echo "Response: $HTTP_RESPONSE"
                
                # Show only essential debugging info
                case $CURL_EXIT_CODE in
                  6) echo "üîç DNS resolution failed for api.cursor.com" ;;
                  7) echo "üîç Connection failed - DNS resolved but couldn't connect" ;;
                  28) echo "üîç Request timeout - server not responding" ;;
                  35) echo "üîç SSL/TLS handshake failed" ;;
                  43) echo "üîç Bad curl parameter - command syntax error" ;;
                  56) echo "üîç Network data transfer failed" ;;
                  60) echo "üîç SSL certificate validation failed" ;;
                  *) echo "üîç Unknown curl error - see https://curl.se/libcurl/c/libcurl-errors.html" ;;
                esac
                
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Cursor API request failed - curl exit code $CURL_EXIT_CODE" >> $GITHUB_OUTPUT
                exit 1
              fi
              
              # Extract HTTP status and response body
              echo "üîç Raw HTTP response:"
              echo "$HTTP_RESPONSE"
              
              # Without write-out format, infer status from response content patterns
              CURSOR_RESPONSE="$HTTP_RESPONSE"
              
              # Try to determine HTTP status from response content patterns
              if echo "$CURSOR_RESPONSE" | grep -q '"id":\|"agent":{'; then
                HTTP_STATUS="200"  # Looks like successful JSON response
              elif echo "$CURSOR_RESPONSE" | grep -q -i "unauthorized\|invalid.*key\|authentication"; then
                HTTP_STATUS="401"  # Authentication error
              elif echo "$CURSOR_RESPONSE" | grep -q -i "forbidden\|access.*denied"; then
                HTTP_STATUS="403"  # Access forbidden  
              elif echo "$CURSOR_RESPONSE" | grep -q -i "not found\|404"; then
                HTTP_STATUS="404"  # Not found
              elif echo "$CURSOR_RESPONSE" | grep -q -i "server error\|internal error\|500"; then
                HTTP_STATUS="500"  # Server error
              elif [ -z "$CURSOR_RESPONSE" ] || echo "$CURSOR_RESPONSE" | grep -q -i "could not resolve\|connection.*failed"; then
                HTTP_STATUS="000"  # Connection failed
              else
                HTTP_STATUS="999"  # Unknown status, assume success if JSON-like
                echo "‚ö†Ô∏è  Could not determine HTTP status, assuming success based on response content"
              fi
              
              echo "üìä API Response Details:"
              echo "  HTTP Status: $HTTP_STATUS"
              echo "  Response Body: $CURSOR_RESPONSE"
              
              # Handle different HTTP status codes
              case "$HTTP_STATUS" in
                "200"|"201")
                  echo "‚úÖ API request successful (HTTP $HTTP_STATUS)"
                  ;;
                "401")
                  echo "‚ùå Authentication failed (HTTP 401 Unauthorized)"
                  echo "This indicates the CURSOR_API_KEY is invalid, expired, or malformed"
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Cursor API authentication failed - invalid API key" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
                "403")
                  echo "‚ùå Access forbidden (HTTP 403 Forbidden)"
                  echo "The API key may not have permission to create agents"
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Cursor API access forbidden - insufficient permissions" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
                "429")
                  echo "‚ùå Rate limit exceeded (HTTP 429 Too Many Requests)"
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Cursor API rate limit exceeded" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
                "500"|"502"|"503"|"504")
                  echo "‚ùå Server error (HTTP $HTTP_STATUS)"
                  echo "Cursor API is experiencing server issues"
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Cursor API server error (HTTP $HTTP_STATUS)" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
                *)
                  echo "‚ùå Unexpected HTTP status: $HTTP_STATUS"
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Cursor API unexpected response (HTTP $HTTP_STATUS)" >> $GITHUB_OUTPUT
                  exit 1
                  ;;
              esac
              
              # Parse agent ID from response (aligned with TypeScript adapter format)
              AGENT_ID=$(echo "$CURSOR_RESPONSE" | jq -r '.agent.id // .id // empty' 2>/dev/null)
              if [ -z "$AGENT_ID" ]; then
                echo "‚ùå Failed to extract agent ID from response"
                echo "Response may be malformed or missing 'agent.id' or 'id' field"
                echo "Raw response: $CURSOR_RESPONSE"
                
                # Check if response contains error information
                ERROR_CODE=$(echo "$CURSOR_RESPONSE" | jq -r '.code // empty' 2>/dev/null)
                ERROR_MESSAGE=$(echo "$CURSOR_RESPONSE" | jq -r '.message // empty' 2>/dev/null)
                
                if [ -n "$ERROR_CODE" ] && [ -n "$ERROR_MESSAGE" ]; then
                  echo "API Error Details: code='$ERROR_CODE', message='$ERROR_MESSAGE'"
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Cursor API error: $ERROR_CODE - $ERROR_MESSAGE" >> $GITHUB_OUTPUT
                else
                  echo "success=false" >> $GITHUB_OUTPUT
                  echo "error=Failed to create Cursor agent - malformed response" >> $GITHUB_OUTPUT
                fi
                exit 1
              fi

              echo "‚úÖ Created Cursor agent: $AGENT_ID"
              
              # Agent created successfully - Cursor will work independently and create PR  
              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=false" >> $GITHUB_OUTPUT  # Changes will come via PR
              echo "output=Cursor agent created successfully, working independently" >> $GITHUB_OUTPUT
              echo "agent_id=$AGENT_ID" >> $GITHUB_OUTPUT
              ;;

            "codex")
              echo "ü§ñ Using OpenAI Codex API..."
              
              if [ -z "$OPENAI_API_KEY" ]; then
                echo "‚ùå OpenAI API key not configured"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Missing OpenAI API key" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Use OpenAI API to generate code changes
              OPENAI_RESPONSE=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d "{
                  \"model\": \"gpt-4-turbo-preview\",
                  \"messages\": [
                    {
                      \"role\": \"system\",
                      \"content\": \"You are a code migration assistant. Apply the requested changes to the codebase and respond with specific file modifications needed.\"
                    },
                    {
                      \"role\": \"user\",
                      \"content\": $(echo "$AGENT_INSTRUCTIONS" | jq -Rs .)
                    }
                  ],
                  \"max_tokens\": 4000,
                  \"temperature\": 0.1
                }")

              echo "OpenAI API Response: $OPENAI_RESPONSE"
              
              # For now, create a placeholder file with the response
              echo "$OPENAI_RESPONSE" > "codex-migration-output.json"
              git add -A

              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=true" >> $GITHUB_OUTPUT
              echo "output=Codex generated migration suggestions" >> $GITHUB_OUTPUT
              ;;

            "mock")
              echo "üß™ Using mock agent for testing..."
              
              # Original mock behavior
              sleep 5
              echo "// Migration step $STEP_ID completed by $AGENT agent" >> src/migration-log.txt
              git add -A

              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=true" >> $GITHUB_OUTPUT
              echo "output=Mock agent completed successfully" >> $GITHUB_OUTPUT
              ;;

            *)
              echo "‚ùå Unknown agent type: $AGENT"
              echo "success=false" >> $GITHUB_OUTPUT
              echo "error=Unknown agent type: $AGENT" >> $GITHUB_OUTPUT
              exit 1
              ;;
          esac

          # Handle mock agent git changes (cloud agents work independently)
          if [ "$AGENT" = "mock" ] && ! git diff --staged --quiet; then
            git commit -m "Apply migration: $MIGRATION_ID step $STEP_ID

          Mock agent changes for testing.

          Migration: ${{ steps.migration.outputs.title }}
          Step: $STEP_ID

          ü§ñ Generated by Hachiko"
          fi

          echo "‚úÖ Agent execution completed"

      - name: Agent execution completed
        if: steps.execute.outputs.success == 'true'
        run: |
          echo "‚úÖ Agent completed migration step successfully"
          echo "The agent should have created a PR with the migration changes"
          echo "Output: ${{ steps.execute.outputs.output }}"

      - name: Handle execution failure
        if: steps.execute.outputs.success != 'true'
        env:
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
          STEP_ID: ${{ github.event.inputs.step_id }}
        run: |
          echo "‚ùå Migration execution failed for $MIGRATION_ID step $STEP_ID"
          echo "Migration status will be inferred as 'paused' based on the failed PR attempt"
          echo "Error: ${{ steps.execute.outputs.error }}"
          exit 1

      - name: Trigger migration-dashboard update
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Triggering migration-dashboard update..."
          gh workflow run migration-dashboard.yml -f action="update_issue"
