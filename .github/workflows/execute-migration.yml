name: Execute Migration Step

# Triggered by migration-dashboard workflow or manually
on:
  workflow_dispatch:
    inputs:
      migration_id:
        description: "Migration ID to execute"
        required: true
        type: string
      step_id:
        description: "Step number to execute"
        required: true
        type: string
      force:
        description: "Force execution even if already in progress"
        required: false
        type: boolean
        default: false

permissions:
  contents: write # To create PRs and update files
  issues: write # To update control-plane issue
  pull-requests: write # To create and manage PRs
  actions: write # To trigger workflow dispatches

jobs:
  execute-migration-step:
    name: Execute Migration Step
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@fe02b34f77f8bc703788d5817da081398fad5dd2 # v4.0.0

      - name: Setup Node.js
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8 # v4.0.3
        with:
          node-version: 22
          cache: "pnpm"

      - name: Install dependencies
        run: |
          pnpm install
          pnpm build

      - name: Load migration document
        id: migration
        env:
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
        run: |
          MIGRATION_FILE="migrations/${MIGRATION_ID}.md"

          # Check if migration file exists
          if [ ! -f "$MIGRATION_FILE" ]; then
            echo "‚ùå Migration file not found: $MIGRATION_FILE"
            exit 1
          fi

          # Extract and parse frontmatter
          FRONTMATTER=$(awk '/^---$/{if(f==1) exit; f=1; next} f' "$MIGRATION_FILE")

          if [ -z "$FRONTMATTER" ]; then
            echo "‚ùå No frontmatter found in migration file"
            exit 1
          fi

          # Parse key fields (simplified YAML parsing)
          TITLE=$(echo "$FRONTMATTER" | grep "^title:" | sed 's/title: *//' | tr -d "'" | tr -d '"')
          AGENT=$(echo "$FRONTMATTER" | grep "^agent:" | sed 's/agent: *//' | tr -d "'" | tr -d '"')
          STATUS=$(echo "$FRONTMATTER" | grep "^status:" | sed 's/status: *//' | tr -d "'" | tr -d '"')
          CURRENT_STEP=$(echo "$FRONTMATTER" | grep "^current_step:" | sed 's/current_step: *//')
          TOTAL_STEPS=$(echo "$FRONTMATTER" | grep "^total_steps:" | sed 's/total_steps: *//')

          echo "migration_file=$MIGRATION_FILE" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "agent=$AGENT" >> $GITHUB_OUTPUT
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "current_step=$CURRENT_STEP" >> $GITHUB_OUTPUT
          echo "total_steps=$TOTAL_STEPS" >> $GITHUB_OUTPUT

          echo "üìã Migration: $TITLE"
          echo "ü§ñ Agent: $AGENT"
          echo "üìä Status: $STATUS"
          echo "üìà Progress: $CURRENT_STEP/$TOTAL_STEPS"

      - name: Validate execution conditions
        env:
          MIGRATION_STATUS: ${{ steps.migration.outputs.status }}
          CURRENT_STEP: ${{ steps.migration.outputs.current_step }}
          REQUESTED_STEP: ${{ github.event.inputs.step_id }}
          FORCE: ${{ github.event.inputs.force }}
        run: |
          echo "Validating execution conditions..."

          # Check if migration is in a valid state for execution
          if [ "$MIGRATION_STATUS" = "completed" ] && [ "$FORCE" != "true" ]; then
            echo "‚ùå Migration already completed. Use force=true to override."
            exit 1
          fi

          if [ "$MIGRATION_STATUS" = "in_progress" ] && [ "$FORCE" != "true" ]; then
            echo "‚ùå Migration already in progress. Use force=true to override."
            exit 1
          fi

          # Validate step number - allow current step or next step (for automatic advancement)
          NEXT_STEP=$((CURRENT_STEP + 1))
          if [ "$REQUESTED_STEP" != "$CURRENT_STEP" ] && [ "$REQUESTED_STEP" != "$NEXT_STEP" ] && [ "$FORCE" != "true" ]; then
            echo "‚ùå Requested step ($REQUESTED_STEP) doesn't match current step ($CURRENT_STEP) or next step ($NEXT_STEP)"
            exit 1
          fi
          
          if [ "$REQUESTED_STEP" = "$NEXT_STEP" ]; then
            echo "üîÑ Advancing to next step: $REQUESTED_STEP (current: $CURRENT_STEP)"
          fi

          if [ "$REQUESTED_STEP" = "$NEXT_STEP" ]; then
            echo "üîÑ Advancing to next step: $REQUESTED_STEP (current: $CURRENT_STEP)"
          fi

          if [ "$REQUESTED_STEP" = "$NEXT_STEP" ]; then
            echo "üîÑ Advancing to next step: $REQUESTED_STEP (current: $CURRENT_STEP)"
          fi

          echo "‚úÖ Execution conditions validated"

      - name: Configure git for agents
        run: |
          # Configure git for potential agent commits
          git config user.name "hachiko[bot]"
          git config user.email "hachiko@users.noreply.github.com"

          echo "‚úÖ Git configured for agent use"

      - name: Update migration status to in_progress
        env:
          MIGRATION_FILE: ${{ steps.migration.outputs.migration_file }}
          STEP_ID: ${{ github.event.inputs.step_id }}
        run: |
          echo "üìù Updating migration status..."

          # Update frontmatter in migration document
          # This is a simplified approach - in production, we'd use proper YAML parsing
          sed -i "s/status: .*/status: in_progress/" "$MIGRATION_FILE"
          sed -i "s/current_step: .*/current_step: $STEP_ID/" "$MIGRATION_FILE"
          sed -i "s/last_updated: .*/last_updated: $(date -u +%Y-%m-%dT%H:%M:%SZ)/" "$MIGRATION_FILE"

          # Commit the status update
          git add "$MIGRATION_FILE"
          git commit -m "Update migration status: ${{ github.event.inputs.migration_id }} step $STEP_ID in progress"

          echo "‚úÖ Migration status updated"

      - name: Execute migration with cloud agent
        id: execute
        env:
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
          MIGRATION_FILE: ${{ steps.migration.outputs.migration_file }}
          AGENT: ${{ steps.migration.outputs.agent }}
          STEP_ID: ${{ github.event.inputs.step_id }}
          DEVIN_API_KEY: ${{ secrets.DEVIN_API_KEY }}
          DEVIN_ORG_ID: ${{ secrets.DEVIN_ORG_ID || vars.DEVIN_ORG_ID }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          CURSOR_WEBHOOK_URL: ${{ secrets.CURSOR_WEBHOOK_URL }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "üöÄ Executing migration step with $AGENT agent..."

          # Generate agent instructions using CLI
          AGENT_INSTRUCTIONS=$(pnpm migration get-agent-instructions "$MIGRATION_ID" "$STEP_ID" "$AGENT" --repository "${{ github.repository }}")

          # Execute based on agent type
          case "$AGENT" in
            "devin")
              echo "ü§ñ Using Devin API v3beta1..."
              
              if [ -z "$DEVIN_API_KEY" ] || [ -z "$DEVIN_ORG_ID" ]; then
                echo "‚ùå Devin API credentials not configured"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Missing Devin API credentials" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Create Devin session
              echo "Creating Devin session..."
              SESSION_RESPONSE=$(curl -s -X POST "https://api.devin.ai/v3beta1/organizations/$DEVIN_ORG_ID/sessions" \
                -H "Authorization: Bearer $DEVIN_API_KEY" \
                -H "Content-Type: application/json" \
                -H "User-Agent: Hachiko/1.0" \
                -d "{
                  \"name\": \"Hachiko Migration: $MIGRATION_ID Step $STEP_ID\",
                  \"description\": \"Automated migration execution - Step $STEP_ID\",
                  \"repositoryUrl\": \"https://github.com/${{ github.repository }}\",
                  \"branch\": \"main\",
                  \"prompt\": $(echo "$AGENT_INSTRUCTIONS" | jq -Rs .)
                }")

              echo "Devin API Response: $SESSION_RESPONSE"
              
              # Extract session_id from API response (changed from .id to .session_id)
              SESSION_ID=$(echo "$SESSION_RESPONSE" | jq -r '.session_id // empty')
              if [ -z "$SESSION_ID" ]; then
                echo "‚ùå Failed to create Devin session"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Failed to create Devin session" >> $GITHUB_OUTPUT
                exit 1
              fi

              echo "‚úÖ Created Devin session: $SESSION_ID"
              echo "üîó Session URL: https://app.devin.ai/sessions/$SESSION_ID"
              
              # Session created successfully - Devin will work independently and create PR
              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=false" >> $GITHUB_OUTPUT  # Changes will come via PR
              echo "output=Devin session created successfully, working independently" >> $GITHUB_OUTPUT
              echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
              ;;

            "cursor")
              echo "ü§ñ Using Cursor API..."
              
              if [ -z "$CURSOR_API_KEY" ]; then
                echo "‚ùå Cursor API key not configured"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Missing Cursor API key" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Create Cursor agent task
              CURSOR_AUTH=$(echo -n "$CURSOR_API_KEY:" | base64)
              
              # Prepare webhook URL field if provided
              if [ -n "$CURSOR_WEBHOOK_URL" ]; then
                WEBHOOK_FIELD=",\"webhook_url\": $(echo "$CURSOR_WEBHOOK_URL" | jq -Rs .)"
              else
                WEBHOOK_FIELD=""
              fi
              
              CURSOR_RESPONSE=$(curl -s -X POST "https://api.cursor.com/v0/agents" \
                -H "Authorization: Basic $CURSOR_AUTH" \
                -H "Content-Type: application/json" \
                -H "User-Agent: Hachiko/1.0" \
                -d "{
                  \"task\": $(echo "$AGENT_INSTRUCTIONS" | jq -Rs .),
                  \"repository_url\": \"https://github.com/${{ github.repository }}\",
                  \"branch\": \"main\",
                  \"metadata\": {
                    \"plan_id\": \"$MIGRATION_ID\",
                    \"step_id\": \"$STEP_ID\"
                  }${WEBHOOK_FIELD}
                }")

              echo "Cursor API Response: $CURSOR_RESPONSE"
              
              AGENT_ID=$(echo "$CURSOR_RESPONSE" | jq -r '.agent.id // empty')
              if [ -z "$AGENT_ID" ]; then
                echo "‚ùå Failed to create Cursor agent"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Failed to create Cursor agent" >> $GITHUB_OUTPUT
                exit 1
              fi

              echo "‚úÖ Created Cursor agent: $AGENT_ID"
              
              # Agent created successfully - Cursor will work independently and create PR  
              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=false" >> $GITHUB_OUTPUT  # Changes will come via PR
              echo "output=Cursor agent created successfully, working independently" >> $GITHUB_OUTPUT
              echo "agent_id=$AGENT_ID" >> $GITHUB_OUTPUT
              ;;

            "codex")
              echo "ü§ñ Using OpenAI Codex API..."
              
              if [ -z "$OPENAI_API_KEY" ]; then
                echo "‚ùå OpenAI API key not configured"
                echo "success=false" >> $GITHUB_OUTPUT
                echo "error=Missing OpenAI API key" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Use OpenAI API to generate code changes
              OPENAI_RESPONSE=$(curl -s -X POST "https://api.openai.com/v1/chat/completions" \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d "{
                  \"model\": \"gpt-4-turbo-preview\",
                  \"messages\": [
                    {
                      \"role\": \"system\",
                      \"content\": \"You are a code migration assistant. Apply the requested changes to the codebase and respond with specific file modifications needed.\"
                    },
                    {
                      \"role\": \"user\",
                      \"content\": $(echo "$AGENT_INSTRUCTIONS" | jq -Rs .)
                    }
                  ],
                  \"max_tokens\": 4000,
                  \"temperature\": 0.1
                }")

              echo "OpenAI API Response: $OPENAI_RESPONSE"
              
              # For now, create a placeholder file with the response
              echo "$OPENAI_RESPONSE" > "codex-migration-output.json"
              git add -A

              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=true" >> $GITHUB_OUTPUT
              echo "output=Codex generated migration suggestions" >> $GITHUB_OUTPUT
              ;;

            "mock")
              echo "üß™ Using mock agent for testing..."
              
              # Original mock behavior
              sleep 5
              echo "// Migration step $STEP_ID completed by $AGENT agent" >> src/migration-log.txt
              git add -A

              echo "success=true" >> $GITHUB_OUTPUT
              echo "changes_made=true" >> $GITHUB_OUTPUT
              echo "output=Mock agent completed successfully" >> $GITHUB_OUTPUT
              ;;

            *)
              echo "‚ùå Unknown agent type: $AGENT"
              echo "success=false" >> $GITHUB_OUTPUT
              echo "error=Unknown agent type: $AGENT" >> $GITHUB_OUTPUT
              exit 1
              ;;
          esac

          # Handle mock agent git changes (cloud agents work independently)
          if [ "$AGENT" = "mock" ] && ! git diff --staged --quiet; then
            git commit -m "Apply migration: $MIGRATION_ID step $STEP_ID

          Mock agent changes for testing.

          Migration: ${{ steps.migration.outputs.title }}
          Step: $STEP_ID

          ü§ñ Generated by Hachiko"
          fi

          echo "‚úÖ Agent execution completed"

      - name: Agent execution completed
        if: steps.execute.outputs.success == 'true'
        run: |
          echo "‚úÖ Agent completed migration step successfully"
          echo "The agent should have created a PR with the migration changes"
          echo "Output: ${{ steps.execute.outputs.output }}"

      - name: Handle execution failure
        if: steps.execute.outputs.success != 'true'
        env:
          MIGRATION_FILE: ${{ steps.migration.outputs.migration_file }}
          MIGRATION_ID: ${{ github.event.inputs.migration_id }}
        run: |
          echo "‚ùå Migration execution failed"

          # Update migration status to failed
          sed -i "s/status: .*/status: failed/" "$MIGRATION_FILE"
          sed -i "s/last_updated: .*/last_updated: $(date -u +%Y-%m-%dT%H:%M:%SZ)/" "$MIGRATION_FILE"

          # Add error message
          if ! grep -q "^error:" "$MIGRATION_FILE"; then
            sed -i "/^last_updated:/a error: Agent execution failed" "$MIGRATION_FILE"
          else
            sed -i "s/error: .*/error: Agent execution failed/" "$MIGRATION_FILE"
          fi

          git add "$MIGRATION_FILE"
          git commit -m "Mark migration as failed: $MIGRATION_ID"
          git push origin main

          echo "Migration marked as failed in repository"
          exit 1

      - name: Trigger migration-dashboard update
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîÑ Triggering migration-dashboard update..."
          gh workflow run migration-dashboard.yml -f action="update_issue"
